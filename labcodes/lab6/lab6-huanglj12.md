# lab6 report

##[练习1]使用 Round Robin 调度算法
> ucore的调度执行过程：init在程序开始执行，所有进程创建之前被调用。 enqueue在进程加入就绪队列时被调用。 dequeue在进程被移出就绪队列时被调用。 pick_next在进程切换时被调用，用它的返回值作为切换到的进程。 proc_tick在产生时钟中断时被调用。
> ”多级反馈队列调度算法“设计：有一个队列的列表，它是队列的总调度器，由它决定从哪个队列里pick_next作为切换到的进程。可以有多个队列，它的功能可能就是实现一个“Round Robin调度算法”或“Stride Scheduling调度算法”。“总调度器”把一个进程绑定在哪个队列上，那么对这个进程的enqueue、dequeue都由相应的队列执行。发生proc_tick时，应该调用上一次选出切换进程的队列的proc_tick。

##[练习2]实现 Stride Scheduling 调度算法
> 具体实现：
> 根据宏不同USE_SKEW_HEAP，为调度算法定义了不同的行为。宏为1时使用左式堆（斜堆），效率可能更高。
> 初始化：队列内进程数量为0，根据宏初始化堆或链表
> 入队：加入堆或加入链表，为进程分配时间片。更新调度队列中进程的总数量。（如果优先级未被初始化过，在加入队列时初始化它）
> 出队：从堆中删除或从链表中删除。更新调度队列中进程的总数量。
> 选取：如果使用左式堆，选取堆顶元素即可；否则，遍历链表中的元素，找出lab6_stride最小的进程。
> 时钟中断：时间片减一。如果时间片用尽，重新调度

## 重要的知识点
> Round Robin调度算法、Stride Scheduling调度算法